
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/drand/drand/beacon/beacon.go (76.7%)</option>
				
				<option value="file1">github.com/drand/drand/beacon/chain.go (81.3%)</option>
				
				<option value="file2">github.com/drand/drand/beacon/convert.go (100.0%)</option>
				
				<option value="file3">github.com/drand/drand/beacon/handler.go (63.4%)</option>
				
				<option value="file4">github.com/drand/drand/beacon/store.go (61.5%)</option>
				
				<option value="file5">github.com/drand/drand/beacon/sync.go (73.7%)</option>
				
				<option value="file6">github.com/drand/drand/beacon/ticker.go (91.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package beacon

import (
        "bytes"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "math"
        "time"

        "github.com/drand/drand/key"
        "github.com/drand/kyber"
)

// Beacon holds the randomness as well as the info to verify it.
type Beacon struct {
        // PreviousSig is the previous signature generated
        PreviousSig []byte
        // Round is the round number this beacon is tied to
        Round uint64
        // Signature is the BLS deterministic signature over Round || PreviousRand
        Signature []byte
}

func (b *Beacon) Equal(b2 *Beacon) bool <span class="cov0" title="0">{
        return bytes.Equal(b.PreviousSig, b2.PreviousSig) &amp;&amp;
                b.Round == b2.Round &amp;&amp;
                bytes.Equal(b.Signature, b2.Signature)

}</span>

func (b *Beacon) Marshal() ([]byte, error) <span class="cov7" title="61">{
        return json.Marshal(b)
}</span>

func (b *Beacon) Unmarshal(buff []byte) error <span class="cov8" title="95">{
        return json.Unmarshal(buff, b)
}</span>

// Randomness returns the hashed signature. It is an example that uses sha256,
// but it could use blake2b for example.
func (b *Beacon) Randomness() []byte <span class="cov0" title="0">{
        return RandomnessFromSignature(b.Signature)
}</span>

func (b *Beacon) GetRound() uint64 <span class="cov3" title="6">{
        return b.Round
}</span>

func RandomnessFromSignature(sig []byte) []byte <span class="cov0" title="0">{
        out := sha256.Sum256(sig)
        return out[:]
}</span>

func (b *Beacon) String() string <span class="cov7" title="54">{
        return fmt.Sprintf("{ round: %d, sig: %s, prevSig: %s }", b.Round, shortSigStr(b.Signature), shortSigStr(b.PreviousSig))
}</span>

// VerifyBeacon returns an error if the given beacon does not verify given the
// public key. The public key "point" can be obtained from the
// `key.DistPublic.Key()` method. The distributed public is the one written in
// the configuration file of the network.
func VerifyBeacon(pubkey kyber.Point, b *Beacon) error <span class="cov6" title="36">{
        prevSig := b.PreviousSig
        round := b.Round
        msg := Message(round, prevSig)
        return key.Scheme.VerifyRecovered(pubkey, msg, b.Signature)
}</span>

// Verify is similar to verify beacon but doesn't require to get the full beacon
// structure.
func Verify(pubkey kyber.Point, prevSig, signature []byte, round uint64) error <span class="cov0" title="0">{
        return VerifyBeacon(pubkey, &amp;Beacon{
                Round:       round,
                PreviousSig: prevSig,
                Signature:   signature,
        })
}</span>

// Message returns a slice of bytes as the message to sign or to verify
// alongside a beacon signature.
// H ( prevSig || currRound)
func Message(currRound uint64, prevSig []byte) []byte <span class="cov10" title="259">{
        h := sha256.New()
        h.Write(prevSig)
        h.Write(roundToBytes(currRound))
        return h.Sum(nil)
}</span>

// TimeOfRound is returning the time the current round should happen
func TimeOfRound(period time.Duration, genesis int64, round uint64) int64 <span class="cov2" title="2">{
        if round == 0 </span><span class="cov0" title="0">{
                return genesis
        }</span>
        // - 1 because genesis time is for 1st round already
        <span class="cov2" title="2">return genesis + int64((round-1)*uint64(period.Seconds()))</span>
}

func CurrentRound(now int64, period time.Duration, genesis int64) uint64 <span class="cov7" title="47">{
        nextRound, _ := NextRound(now, period, genesis)
        if nextRound &lt;= 1 </span><span class="cov0" title="0">{
                return nextRound
        }</span>
        <span class="cov7" title="47">return nextRound - 1</span>
}

// NextRound returns the next upcoming round and its UNIX time given the genesis
// time and the period.
// round at time genesis = round 1. Round 0 is fixed.
func NextRound(now int64, period time.Duration, genesis int64) (uint64, int64) <span class="cov9" title="205">{
        if now &lt; genesis </span><span class="cov5" title="21">{
                return 1, genesis
        }</span>
        <span class="cov9" title="184">fromGenesis := now - genesis
        // we take the time from genesis divided by the periods in seconds, that
        // gives us the number of periods since genesis. We add +1 since we want the
        // next round. We also add +1 because round 1 starts at genesis time.
        nextRound := uint64(math.Floor(float64(fromGenesis)/period.Seconds())) + 1
        nextTime := genesis + int64(nextRound*uint64(period.Seconds()))
        return nextRound + 1, nextTime</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package beacon

import (
        "bytes"
        "context"
        "fmt"

        "github.com/drand/drand/key"
        "github.com/drand/drand/log"
        "github.com/drand/drand/net"
        "github.com/drand/drand/protobuf/drand"
)

// chainStore is a Store that deals with reconstructing the beacons, sync when
// needed and arranges the head
type chainStore struct {
        Store
        l             log.Logger
        client        net.ProtocolClient
        safe          *cryptoSafe
        ticker        *ticker
        done          chan bool
        newPartials   chan partialInfo
        newBeaconCh   chan *Beacon
        lastInserted  chan *Beacon
        requestSync   chan likeBeacon
        nonSyncBeacon chan *Beacon
}

func newChainStore(l log.Logger, client net.ProtocolClient, safe *cryptoSafe, s Store, ticker *ticker) *chainStore <span class="cov4" title="11">{
        chain := &amp;chainStore{
                l:             l,
                client:        client,
                safe:          safe,
                Store:         s,
                done:          make(chan bool, 1),
                ticker:        ticker,
                newPartials:   make(chan partialInfo, 10),
                newBeaconCh:   make(chan *Beacon, 100),
                requestSync:   make(chan likeBeacon, 10),
                lastInserted:  make(chan *Beacon, 1),
                nonSyncBeacon: make(chan *Beacon, 1),
        }
        // TODO maybe look if it's worth having multiple workers there
        go chain.runChainLoop()
        go chain.runAggregator()
        return chain
}</span>

func (c *chainStore) NewValidPartial(addr string, p *drand.PartialBeaconPacket) <span class="cov9" title="172">{
        c.newPartials &lt;- partialInfo{
                addr: addr,
                p:    p,
        }
}</span>

func (c *chainStore) NewBeacon(addr string, proto *drand.BeaconPacket) <span class="cov0" title="0">{
        c.newBeaconCh &lt;- protoToBeacon(proto)
}</span>

func (c *chainStore) Stop() <span class="cov4" title="11">{
        c.Store.Close()
        close(c.done)
}</span>

// we store partials that are up to this amount of rounds more than the last
// beacon we have - it is useful to store partials that may come in advance,
// especially in case of a quick catchup.
var partialCacheStoreLimit = 3

// runAggregator runs a continuous loop that tries to aggregate partial
// signatures when it can
func (c *chainStore) runAggregator() <span class="cov4" title="11">{
        lastBeacon, err := c.Store.Last()
        if err != nil </span><span class="cov0" title="0">{
                c.l.Fatal("chain_aggregator", "loading", "last_beacon", err)
        }</span>
        <span class="cov4" title="11">var caches = []*roundCache{
                newRoundCache(lastBeacon.Round+1, lastBeacon.Signature),
        }
        for </span><span class="cov9" title="226">{
                select </span>{
                case &lt;-c.done:<span class="cov4" title="11">
                        return</span>
                case lastBeacon = &lt;-c.lastInserted:<span class="cov7" title="43">
                        // filter all caches inferior to this beacon
                        var newCaches []*roundCache
                        for _, cache := range caches </span><span class="cov7" title="50">{
                                if cache.round &lt;= lastBeacon.Round </span><span class="cov7" title="47">{
                                        continue</span>
                                }
                                <span class="cov2" title="3">newCaches = append(newCaches, cache)</span>
                        }
                        <span class="cov7" title="43">caches = newCaches
                        break</span>
                case partial := &lt;-c.newPartials:<span class="cov9" title="172">
                        // look if we have info for this round first
                        pRound := partial.p.GetRound()
                        ginfo, err := c.safe.GetInfo(pRound)
                        if err != nil </span><span class="cov0" title="0">{
                                c.l.Error("no_info_for", partial.p.GetRound())
                                break</span>
                        }

                        // look if we are already have a cache for this round
                        <span class="cov9" title="172">var cache *roundCache
                        for _, c := range caches </span><span class="cov9" title="176">{
                                if !c.tryAppend(partial.p) </span><span class="cov6" title="35">{
                                        continue</span>
                                }
                                <span class="cov9" title="141">cache = c</span>
                        }

                        <span class="cov9" title="172">if cache == nil </span><span class="cov6" title="37">{
                                cache = newRoundCache(partial.p.GetRound(), partial.p.GetPreviousSig())
                                caches = append(caches, cache)
                                if !cache.tryAppend(partial.p) </span><span class="cov0" title="0">{
                                        c.l.Fatal("bug_cache_partial")
                                }</span>
                        } else<span class="cov9" title="135"> if cache.done </span><span class="cov7" title="55">{
                                c.l.Debug("store_partial", "ignored", "round", cache.round, "already_reconstructed")
                                break</span>
                        }

                        <span class="cov8" title="117">thr := ginfo.group.Threshold
                        c.l.Debug("store_partial", partial.addr, "round", cache.round, "len_partials", fmt.Sprintf("%d/%d", cache.Len(), thr))
                        // look if we want to store ths partial anyway
                        shouldStore := pRound &gt;= lastBeacon.Round+1 &amp;&amp; pRound &lt;= lastBeacon.Round+uint64(partialCacheStoreLimit+1)
                        // check if we can reconstruct
                        if !shouldStore </span><span class="cov4" title="7">{
                                c.l.Error("ignoring_partial", partial.p.GetRound(), "last_beacon_stored", lastBeacon.Round)
                                break</span>
                        }
                        <span class="cov8" title="110">if cache.Len() &lt; thr </span><span class="cov8" title="69">{
                                break</span>
                        }

                        <span class="cov7" title="41">pub := ginfo.pub
                        n := ginfo.group.Len()
                        msg := cache.Msg()
                        finalSig, err := key.Scheme.Recover(pub, msg, cache.Partials(), thr, n)
                        if err != nil </span><span class="cov0" title="0">{
                                c.l.Debug("invalid_recovery", err, "round", pRound, "got", fmt.Sprintf("%d/%d", cache.Len(), n))
                                break</span>
                        }
                        <span class="cov7" title="41">if err := key.Scheme.VerifyRecovered(pub.Commit(), msg, finalSig); err != nil </span><span class="cov0" title="0">{
                                c.l.Error("invalid_sig", err, "round", pRound)
                                break</span>
                        }
                        <span class="cov7" title="41">cache.done = true
                        newBeacon := &amp;Beacon{
                                Round:       cache.round,
                                PreviousSig: cache.previousSig,
                                Signature:   finalSig,
                        }
                        c.l.Info("aggregated_beacon", newBeacon.Round)
                        c.newBeaconCh &lt;- newBeacon
                        break</span>
                }
        }
}

func (c *chainStore) runChainLoop() <span class="cov4" title="11">{
        var syncing bool
        var syncingDone = make(chan bool, 1)
        lastBeacon, err := c.Store.Last()
        if err != nil </span><span class="cov0" title="0">{
                c.l.Fatal("store_last_init", err)
        }</span>
        <span class="cov4" title="11">insert := func(newB *Beacon) </span><span class="cov7" title="43">{
                if err := c.Store.Put(newB); err != nil </span><span class="cov0" title="0">{
                        c.l.Fatal("new_beacon_storing", err)
                }</span>
                <span class="cov7" title="43">lastBeacon = newB
                c.l.Info("NEW_BEACON_STORED", newB.String())
                c.lastInserted &lt;- newB
                if !syncing </span><span class="cov7" title="43">{
                        // during syncing we don't do a fast sync
                        select </span>{
                        // only send if it's not full already
                        case c.nonSyncBeacon &lt;- newB:<span class="cov7" title="43"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                }
        }
        <span class="cov4" title="11">for </span><span class="cov7" title="57">{
                select </span>{
                case newBeacon := &lt;-c.newBeaconCh:<span class="cov7" title="46">
                        if isAppendable(lastBeacon, newBeacon) </span><span class="cov7" title="43">{
                                insert(newBeacon)
                                break</span>
                        }
                        // XXX store them for lfutur usage if it's a later round than what
                        // we have
                        <span class="cov2" title="3">c.l.Debug("new_aggregated", "not_appendable", "last", lastBeacon.String(), "new", newBeacon.String())
                        if c.shouldSync(lastBeacon, newBeacon) </span><span class="cov0" title="0">{
                                c.requestSync &lt;- newBeacon
                        }</span>
                case seen := &lt;-c.requestSync:<span class="cov0" title="0">
                        if !c.shouldSync(lastBeacon, seen) || syncing </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">syncing = true
                        go func() </span><span class="cov0" title="0">{
                                // XXX Could do something smarter with context and cancellation
                                // if we got to the right round
                                c.RunSync(context.Background())
                                syncingDone &lt;- true
                        }</span>()
                case &lt;-syncingDone:<span class="cov0" title="0">
                        syncing = false</span>
                case &lt;-c.done:<span class="cov4" title="11">
                        return</span>
                }
        }
}

func isAppendable(lastBeacon, newBeacon *Beacon) bool <span class="cov7" title="51">{
        return newBeacon.Round == lastBeacon.Round+1 &amp;&amp;
                bytes.Equal(lastBeacon.Signature, newBeacon.PreviousSig)
}</span>

type likeBeacon interface {
        GetRound() uint64
}

func (c *chainStore) shouldSync(last *Beacon, newB likeBeacon) bool <span class="cov2" title="3">{
        // we should sync if we are two blocks late
        return newB.GetRound() &gt; last.GetRound()+1
}</span>

// RunSync is a blocking call that tries to sync chain to the highest height
// found
func (c *chainStore) RunSync(ctx context.Context) <span class="cov3" title="4">{
        l, err := c.Store.Last()
        if err != nil </span><span class="cov0" title="0">{
                c.l.Error("run_sync", "load", "last_beacon", err)
                return
        }</span>
        <span class="cov3" title="4">currRound := c.ticker.CurrentRound()
        outCh, err := syncChain(ctx, c.l, c.safe, l, currRound, c.client)
        if err != nil </span><span class="cov0" title="0">{
                c.l.Error("error_sync", err)
                return
        }</span>
        <span class="cov3" title="4">for newB := range outCh </span><span class="cov3" title="5">{
                c.newBeaconCh &lt;- newB
        }</span>
        <span class="cov3" title="4">return</span>
}

func (c *chainStore) AppendedBeaconNoSync() chan *Beacon <span class="cov8" title="97">{
        return c.nonSyncBeacon
}</span>

type partialInfo struct {
        addr string
        p    *drand.PartialBeaconPacket
}

type beaconInfo struct {
        addr   string
        beacon *Beacon
}

type roundCache struct {
        round       uint64
        previous    uint64
        previousSig []byte
        sigs        [][]byte
        seens       map[int]bool
        done        bool
}

func newRoundCache(round uint64, prevSig []byte) *roundCache <span class="cov7" title="48">{
        return &amp;roundCache{
                round:       round,
                previousSig: prevSig,
                seens:       make(map[int]bool),
        }
}</span>

func (cache *roundCache) tryAppend(p *drand.PartialBeaconPacket) bool <span class="cov9" title="213">{
        round := p.GetRound()
        prevSig := p.GetPreviousSig()
        idx, _ := key.Scheme.IndexOf(p.GetPartialSig())
        if _, seen := cache.seens[idx]; seen </span><span class="cov5" title="14">{
                return false
        }</span>

        <span class="cov9" title="199">sameRound := round == cache.round
        samePrevS := bytes.Equal(prevSig, cache.previousSig)
        if sameRound &amp;&amp; samePrevS </span><span class="cov9" title="178">{
                cache.sigs = append(cache.sigs, p.GetPartialSig())
                cache.seens[idx] = true
                return true
        }</span>
        <span class="cov6" title="21">return false</span>
}

func (r *roundCache) Len() int <span class="cov10" title="227">{
        return len(r.sigs)
}</span>

func (r *roundCache) Msg() []byte <span class="cov7" title="41">{
        return Message(r.round, r.previousSig)
}</span>

func (r *roundCache) Partials() [][]byte <span class="cov7" title="41">{
        return r.sigs
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package beacon

import (
        proto "github.com/drand/drand/protobuf/drand"
)

func beaconToProto(b *Beacon) *proto.BeaconPacket <span class="cov10" title="5">{
        return &amp;proto.BeaconPacket{
                PreviousSig: b.PreviousSig,
                Round:       b.Round,
                Signature:   b.Signature,
        }
}</span>

func protoToBeacon(p *proto.BeaconPacket) *Beacon <span class="cov10" title="5">{
        return &amp;Beacon{
                Round:       p.GetRound(),
                Signature:   p.GetSignature(),
                PreviousSig: p.GetPreviousSig(),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package beacon

import (
        "context"
        "encoding/hex"
        "errors"
        "fmt"
        "math/rand"
        "sort"
        "strings"
        "sync"
        "time"

        //"github.com/benbjohnson/clock"

        "github.com/drand/drand/log"
        proto "github.com/drand/drand/protobuf/drand"
        "github.com/drand/kyber/share"
        clock "github.com/jonboulle/clockwork"
        "google.golang.org/grpc/peer"

        "github.com/drand/drand/key"
        "github.com/drand/drand/net"
)

// Config holds the different cryptographc informations necessary to run the
// randomness beacon.
type Config struct {
        // Public key of this node
        Public *key.Node
        // Share of this node in the network
        Share *key.Share
        // Group listing all nodes and public key of the network
        Group *key.Group
        // Clock to use - useful to testing
        Clock clock.Clock
        // Callback to use when a new beacon is created - can be nil and new
        // callbacks can be added afterwards to the beacon
        Callback func(*Beacon)
}

// Handler holds the logic to initiate, and react to the TBLS protocol. Each time
// a full signature can be recosntructed, it saves it to the given Store.
type Handler struct {
        sync.Mutex
        conf *Config
        // to communicate with other drand peers
        client net.ProtocolClient
        // keeps the cryptographic info (group share etc)
        safe *cryptoSafe
        // main logic that treats incoming packet / new beacons created
        chain  *chainStore
        ticker *ticker

        close     chan bool
        addr      string
        started   bool
        stopped   bool
        l         log.Logger
        callbacks *CallbackStore
}

// NewHandler returns a fresh handler ready to serve and create randomness
// beacon
func NewHandler(c net.ProtocolClient, s Store, conf *Config, l log.Logger) (*Handler, error) <span class="cov4" title="11">{
        if conf.Share == nil || conf.Group == nil </span><span class="cov0" title="0">{
                return nil, errors.New("beacon: invalid configuration")
        }</span>
        // Checking we are in the group
        <span class="cov4" title="11">node := conf.Group.Find(conf.Public.Identity)
        if node == nil </span><span class="cov0" title="0">{
                return nil, errors.New("beacon: keypair not included in the given group")
        }</span>
        <span class="cov4" title="11">addr := conf.Public.Address()
        logger := l
        safe := newCryptoSafe()
        safe.SetInfo(conf.Share, node, conf.Group)
        // genesis block at round 0, next block at round 1
        // THIS is to change when one network wants to build on top of another
        // network's chain. Note that if present it overwrites.
        b := &amp;Beacon{
                Signature: conf.Group.GetGenesisSeed(),
                Round:     0,
        }
        s.Put(b)
        ticker := newTicker(conf.Clock, conf.Group.Period, conf.Group.GenesisTime)
        callbacks := NewCallbackStore(s)
        chain := newChainStore(logger, c, safe, callbacks, ticker)
        handler := &amp;Handler{
                conf:      conf,
                client:    c,
                safe:      safe,
                chain:     chain,
                ticker:    ticker,
                addr:      addr,
                close:     make(chan bool),
                l:         logger,
                callbacks: callbacks,
        }
        return handler, nil</span>
}

var errOutOfRound = "out-of-round beacon request"

// ProcessPartialBeacon receives a request for a beacon partial signature. It
// forwards it to the round manager if it is a valid beacon.
func (h *Handler) ProcessPartialBeacon(c context.Context, p *proto.PartialBeaconPacket) (*proto.Empty, error) <span class="cov8" title="128">{
        peer, _ := peer.FromContext(c)
        addr := peer.Addr.String()
        h.l.Debug("received", "request", "from", addr, "round", p.GetRound())

        nextRound, _ := NextRound(h.conf.Clock.Now().Unix(), h.conf.Group.Period, h.conf.Group.GenesisTime)
        currentRound := nextRound - 1

        // we allow one round off in the future because of small clock drifts
        // possible, if a node receives a packet very fast just before his local
        // clock passed to the next round
        if p.GetRound() &gt; nextRound </span><span class="cov0" title="0">{
                h.l.Error("process_partial", addr, "invalid_future_round", p.GetRound(), "current_round", currentRound)
                return nil, fmt.Errorf("invalid round: %d instead of %d", p.GetRound(), currentRound)
        }</span>

        <span class="cov8" title="128">msg := Message(p.GetRound(), p.GetPreviousSig())
        info, err := h.safe.GetInfo(p.GetRound())
        if err != nil </span><span class="cov0" title="0">{
                h.l.Error("process_partial", addr, "no_info_for_round", p.GetRound())
                return nil, errors.New("no info for this round")
        }</span>

        // XXX Remove that evaluation - find another way to show the current dist.
        // key being used
        <span class="cov8" title="128">shortPub := info.pub.Eval(1).V.String()[14:19]
        // verify if request is valid
        if err := key.Scheme.VerifyPartial(info.pub, msg, p.GetPartialSig()); err != nil </span><span class="cov0" title="0">{
                h.l.Error("process_partial", addr, "err", err, "prev_sig", shortSigStr(p.GetPreviousSig()), "curr_round", currentRound, "msg_sign", shortSigStr(msg), "short_pub", shortPub)
                return nil, err
        }</span>
        <span class="cov8" title="128">h.l.Debug("process_partial", addr, "prev_sig", shortSigStr(p.GetPreviousSig()), "curr_round", currentRound, "msg_sign", shortSigStr(msg), "short_pub", shortPub, "status", "OK")
        idx, _ := key.Scheme.IndexOf(p.GetPartialSig())
        if idx == info.index </span><span class="cov0" title="0">{
                h.l.Error("process_partial", addr, "index_got", idx, "index_our", info.index, "advance_packet?", p.GetRound(), "safe", h.safe.String(), "pub", shortPub)
                // XXX error or not ?
                return new(proto.Empty), nil
        }</span>
        <span class="cov8" title="128">h.chain.NewValidPartial(peer.Addr.String(), p)
        return new(proto.Empty), nil</span>
}

// Store returns the store associated with this beacon handler
func (h *Handler) Store() Store <span class="cov0" title="0">{
        return h.chain
}</span>

// Start runs the beacon protocol (threshold BLS signature). The first round
// will sign the message returned by the config.FirstRound() function. If the
// genesis time specified in the group is already passed, Start returns an
// error. In that case, if the group is already running, you should call
// SyncAndRun().
// Round 0 = genesis seed - fixed
// Round 1 starts at genesis time, and is signing over the genesis seed
func (h *Handler) Start() error <span class="cov4" title="10">{
        if h.conf.Clock.Now().Unix() &gt; h.conf.Group.GenesisTime </span><span class="cov0" title="0">{
                h.l.Error("genesis_time", "past", "call", "catchup")
                return errors.New("beacon: genesis time already passed. Call Catchup()")
        }</span>
        <span class="cov4" title="10">_, tTime := NextRound(h.conf.Clock.Now().Unix(), h.conf.Group.Period, h.conf.Group.GenesisTime)
        h.l.Info("beacon", "start")
        go h.run(tTime)
        return nil</span>
}

// Catchup waits the next round's time to participate. This method is called
// when a node stops its daemon (maintenance or else) and get backs in the
// already running network . If the node does not have the previous randomness,
// it sync its local chain with other nodes to be able to participate in the
// next upcoming round.
func (h *Handler) Catchup() <span class="cov1" title="1">{
        h.chain.RunSync(context.Background())
        _, tTime := NextRound(h.conf.Clock.Now().Unix(), h.conf.Group.Period, h.conf.Group.GenesisTime)
        go h.run(tTime)
}</span>

// Transition makes this beacon continuously sync until the time written in the
// "TransitionTime" in the handler's group file, where he will start generating
// randomness. To sync, he contact the nodes listed in the previous group file
// given.
// TODO: it should be better to use the public streaming API but since it is
// likely to change, right now we use the sync API. Later on when API is well
// defined, best to use streaming.
func (h *Handler) Transition(prevGroup *key.Group) error <span class="cov0" title="0">{
        targetTime := h.conf.Group.TransitionTime
        tRound := CurrentRound(targetTime, h.conf.Group.Period, h.conf.Group.GenesisTime)
        tTime := TimeOfRound(h.conf.Group.Period, h.conf.Group.GenesisTime, tRound)
        if tTime != targetTime </span><span class="cov0" title="0">{
                h.l.Fatal("transition_time", "invalid_offset", "expected_time", tTime, "got_time", targetTime)
                return nil
        }</span>

        // register the previous group as well in case it needs to verify the
        // previous entries
        <span class="cov0" title="0">h.safe.SetInfo(nil, h.conf.Public, prevGroup)
        go h.run(targetTime)
        h.chain.RunSync(context.Background())
        return nil</span>
}

func (h *Handler) TransitionNewGroup(newShare *key.Share, newGroup *key.Group) <span class="cov0" title="0">{
        targetTime := newGroup.TransitionTime
        tRound := CurrentRound(targetTime, h.conf.Group.Period, h.conf.Group.GenesisTime)
        tTime := TimeOfRound(h.conf.Group.Period, h.conf.Group.GenesisTime, tRound)
        if tTime != targetTime </span><span class="cov0" title="0">{
                h.l.Fatal("transition_time", "invalid_offset", "expected_time", tTime, "got_time", targetTime)
                return
        }</span>
        <span class="cov0" title="0">h.l.Debug("transition", "new_group", "at_round", tRound)
        h.safe.SetInfo(newShare, h.conf.Public, newGroup)</span>
}

// run will wait until it is supposed to start
func (h *Handler) run(startTime int64) <span class="cov4" title="11">{
        chanTick := h.ticker.ChannelAt(startTime)
        h.l.Debug("run_round", "wait", "until", startTime)
        var current roundInfo
        for </span><span class="cov7" title="97">{
                select </span>{
                case current = &lt;-chanTick:<span class="cov6" title="43">
                        lastBeacon, err := h.chain.Last()
                        if err != nil </span><span class="cov2" title="2">{
                                h.l.Error("beacon_loop", "loading_last", "err", err)
                                break</span>
                        }
                        <span class="cov6" title="41">h.l.Debug("beacon_loop", "new_round", "round", current.round, "lastbeacon", lastBeacon.Round)
                        h.broadcastNextPartial(current, lastBeacon)
                        // if the next round of the last beacon we generated is not the round we
                        // are now, that means there is a gap between the two rounds. In other
                        // words, the chain has halted for that amount of rounds or our
                        // network is not functionning properly.
                        if lastBeacon.Round+1 &lt; current.round </span><span class="cov2" title="3">{

                                // We also launch a sync with the other nodes. If there is one node
                                // that has a higher beacon, we'll build on it next epoch. If
                                // nobody has a higher beacon, then this one will be next if the
                                // network conditions allow for it.
                                // XXX find a way to start the catchup as soon as the runsync is
                                // done. Not critical but leads to faster network recovery.
                                h.l.Debug("beacon_loop", "run_sync", "potential_catchup")
                                // XXX Find a way to not run sync again before another has
                                // finished - maybe merge with chain sync mechanism
                                go h.chain.RunSync(context.Background())
                        }</span>
                case b := &lt;-h.chain.AppendedBeaconNoSync():<span class="cov6" title="43">
                        if b.Round &lt; current.round </span><span class="cov2" title="3">{
                                // When network is down, all alive nodes will broadcast their
                                // signatures periodically with the same period. As soon as one
                                // new beacon is created,i.e. network is up again, this channel
                                // will be triggered and we enter fast mode here.
                                // Since that last node is late, nodes must now hurry up to do
                                // the next beacons in time -&gt; we run the next beacon now
                                // already. If that next beacon is created soon after, this
                                // channel will trigger again etc until we arrive at the correct
                                // round.
                                h.broadcastNextPartial(current, b)
                        }</span>
                case &lt;-h.close:<span class="cov4" title="11">
                        h.l.Debug("beacon_loop", "finished")
                        return</span>
                }
        }
}

func (h *Handler) broadcastNextPartial(current roundInfo, upon *Beacon) <span class="cov6" title="44">{
        ctx := context.Background()
        previousSig := upon.Signature
        round := upon.Round + 1
        if current.round == upon.Round </span><span class="cov0" title="0">{
                // we already have the beacon of the current round for some reasons - on
                // CI it happens due to time shifts -
                // the spec says we should broadcast the current round at the correct
                // tick so we still broadcast a partial signature over it - even though
                // drand guarantees a threshold of nodes already have it
                previousSig = upon.PreviousSig
                round = current.round
        }</span>
        <span class="cov6" title="44">info, err := h.safe.GetInfo(round)
        if err != nil </span><span class="cov0" title="0">{
                h.l.Error("no_info", round, "BUG")
                return
        }</span>
        <span class="cov6" title="44">if info.share == nil </span><span class="cov0" title="0">{
                h.l.Error("no_share", round, "BUG", h.safe.String(), "not_synced_yet?")
                return
        }</span>
        <span class="cov6" title="44">msg := Message(round, previousSig)
        currSig, err := key.Scheme.Sign(info.share.PrivateShare(), msg)
        if err != nil </span><span class="cov0" title="0">{
                h.l.Fatal("beacon_round", fmt.Sprintf("creating signature: %s", err), "round", round)
                return
        }</span>
        <span class="cov6" title="44">shortPub := info.pub.Eval(1).V.String()[14:19]
        h.l.Debug("broadcast_partial", round, "from_prev_sig", shortSigStr(previousSig), "msg_sign", shortSigStr(msg), "short_pub", shortPub)
        packet := &amp;proto.PartialBeaconPacket{
                Round:       round,
                PreviousSig: previousSig,
                PartialSig:  currSig,
        }
        h.chain.NewValidPartial(h.addr, packet)
        for _, id := range info.group.Nodes </span><span class="cov8" title="188">{
                if info.id.Address() == id.Address() </span><span class="cov6" title="44">{
                        continue</span>
                }
                <span class="cov8" title="144">go func(i *key.Identity) </span><span class="cov8" title="144">{
                        h.l.Debug("beacon_round", round, "send_to", i.Address())
                        err := h.client.PartialBeacon(ctx, i, packet)
                        if err != nil </span><span class="cov5" title="16">{
                                h.l.Error("beacon_round", round, "err_request", err, "from", i.Address())
                                if strings.Contains(err.Error(), errOutOfRound) </span><span class="cov0" title="0">{
                                        h.l.Error("beacon_round", round, "node", i.Addr, "reply", "out-of-round")
                                }</span>
                                <span class="cov5" title="16">return</span>
                        }
                }(id.Identity)
        }
}

// Stop the beacon loop from aggregating  further randomness, but it
// finishes the one it is aggregating currently.
func (h *Handler) Stop() <span class="cov4" title="11">{
        h.Lock()
        defer h.Unlock()
        if h.stopped </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="11">close(h.close)
        h.chain.Stop()
        h.ticker.Stop()
        h.stopped = true
        h.l.Info("beacon", "stop")</span>
}

// StopAt will stop the handler at the given time. It is useful when
// transitionining for a resharing.
func (h *Handler) StopAt(stopTime int64) error <span class="cov0" title="0">{
        now := h.conf.Clock.Now().Unix()
        if stopTime &lt;= now </span><span class="cov0" title="0">{
                // actually we can stop in the present but with "Stop"
                return errors.New("can't stop in the past or present")
        }</span>
        <span class="cov0" title="0">duration := time.Duration(stopTime-now) * time.Second
        h.l.Debug("stop_at", stopTime, "sleep_for", duration.Seconds())
        h.conf.Clock.Sleep(duration)
        h.Stop()
        return nil</span>
}

func (h *Handler) AddCallback(fn func(*Beacon)) <span class="cov0" title="0">{
        h.callbacks.AddCallback(fn)
}</span>

var errOutdatedRound = errors.New("current partial signature not for this round")

func shortSigStr(sig []byte) string <span class="cov10" title="452">{
        max := 3
        if len(sig) &lt; max </span><span class="cov0" title="0">{
                max = len(sig)
        }</span>
        <span class="cov10" title="452">return hex.EncodeToString(sig[0:max])</span>
}

func shuffleNodes(nodes []*key.Node) []*key.Node <span class="cov3" title="4">{
        ids := make([]*key.Node, 0, len(nodes))
        for _, id := range nodes </span><span class="cov5" title="18">{
                ids = append(ids, id)
        }</span>
        <span class="cov3" title="4">rand.Shuffle(len(ids), func(i, j int) </span><span class="cov4" title="14">{ ids[i], ids[j] = ids[j], ids[i] }</span>)
        <span class="cov3" title="4">return ids</span>
}

type cryptoInfo struct {
        group   *key.Group
        share   *key.Share
        pub     *share.PubPoly
        startAt uint64
        id      *key.Node
        index   int
}

type cryptoSafe struct {
        sync.Mutex
        infos []*cryptoInfo
}

func newCryptoSafe() *cryptoSafe <span class="cov4" title="11">{
        return &amp;cryptoSafe{}
}</span>

func (c *cryptoSafe) SetInfo(share *key.Share, id *key.Node, group *key.Group) <span class="cov4" title="11">{
        c.Lock()
        defer c.Unlock()
        info := new(cryptoInfo)
        info.id = id
        info.group = group
        info.pub = group.PublicKey.PubPoly()
        if share != nil </span><span class="cov4" title="11">{
                info.share = share
                info.index = share.Share.I
        }</span> else<span class="cov0" title="0"> {
                info.index = int(id.Index)
        }</span>
        <span class="cov4" title="11">if group.TransitionTime != 0 </span><span class="cov0" title="0">{
                time := group.TransitionTime
                info.startAt = CurrentRound(time, group.Period, group.GenesisTime)
        }</span> else<span class="cov4" title="11"> {
                // group started at genesis time
                info.startAt = 0
        }</span>
        <span class="cov4" title="11">c.infos = append(c.infos, info)
        // we sort reverse order so highest round are first
        sort.Slice(c.infos, func(i, j int) bool </span><span class="cov0" title="0">{ return c.infos[i].startAt &gt; c.infos[j].startAt }</span>)
}

func (c *cryptoSafe) GetInfo(round uint64) (*cryptoInfo, error) <span class="cov9" title="353">{
        c.Lock()
        defer c.Unlock()
        for _, info := range c.infos </span><span class="cov9" title="353">{
                if round &gt;= info.startAt </span><span class="cov9" title="353">{
                        return info, nil
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("failed infos for round %d: %+v\n", round, c.infos)
        return nil, fmt.Errorf("no group info for round %d", round)</span>
}

func (c *cryptoSafe) String() string <span class="cov0" title="0">{
        c.Lock()
        defer c.Unlock()
        var out string
        for _, info := range c.infos </span><span class="cov0" title="0">{
                var index = -1
                if info.share != nil </span><span class="cov0" title="0">{
                        index = int(info.share.Share.I)
                }</span>
                <span class="cov0" title="0">shortPub := info.pub.Eval(1).V.String()[14:19]
                out += fmt.Sprintf(" {startAt: %d, index: %d, pub: %s} ", info.startAt, index, shortPub)</span>
        }
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package beacon

import (
        "bytes"
        "encoding/binary"
        "errors"
        "path"
        "sync"

        "github.com/nikkolasg/slog"
        bolt "go.etcd.io/bbolt"
)

// store contains all the definitions and implementation of the logic that
// stores and loads beacon signatures. At the moment of writing, it consists of
// a boltdb key/value database store.

// Store is an interface to store Beacons packets where they can also be
// retrieved to be delivered to end clients.
type Store interface {
        Len() int
        Put(*Beacon) error
        Last() (*Beacon, error)
        Get(round uint64) (*Beacon, error)
        Cursor(func(Cursor))
        Close()
        Del(round uint64) error
}

// Iterate over items in sorted key order. This starts from the
// first key/value pair and updates the k/v variables to the
// next key/value on each iteration.
//
// The loop finishes at the end of the cursor when a nil key is returned.
//    for k, v := c.First(); k != nil; k, v = c.Next() {
//        fmt.Printf("A %s is %s.\n", k, v)
//    }
type Cursor interface {
        First() *Beacon
        Next() *Beacon
        Seek(round uint64) *Beacon
        Last() *Beacon
}

// boldStore implements the Store interface using the kv storage boltdb (native
// golang implementation). Internally, Beacons are stored as JSON-encoded in the
// db file.
type boltStore struct {
        sync.Mutex
        db  *bolt.DB
        len int
}

var beaconBucket = []byte("beacons")

// BoltFileName is the name of the file boltdb writes to
const BoltFileName = "drand.db"

// NewBoltStore returns a Store implementation using the boltdb storage engine.
func NewBoltStore(folder string, opts *bolt.Options) (Store, error) <span class="cov5" title="14">{
        dbPath := path.Join(folder, BoltFileName)
        db, err := bolt.Open(dbPath, 0660, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="14">var baseLen = 0
        // create the bucket already
        err = db.Update(func(tx *bolt.Tx) error </span><span class="cov5" title="14">{
                bucket, err := tx.CreateBucketIfNotExists(beaconBucket)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="14">baseLen += bucket.Stats().KeyN
                return nil</span>
        })

        <span class="cov5" title="14">return &amp;boltStore{
                db:  db,
                len: baseLen,
        }, err</span>
}

func (b *boltStore) Len() int <span class="cov3" title="5">{
        var length = 0
        b.db.View(func(tx *bolt.Tx) error </span><span class="cov3" title="5">{
                bucket := tx.Bucket(beaconBucket)
                length = bucket.Stats().KeyN
                return nil
        }</span>)
        <span class="cov3" title="5">return length</span>
}

func (b *boltStore) Close() <span class="cov4" title="12">{
        if err := b.db.Close(); err != nil </span><span class="cov0" title="0">{
                slog.Debugf("boltdb store: %s", err)
        }</span>
}

// Put implements the Store interface. WARNING: It does NOT verify that this
// beacon is not already saved in the database or not.
func (b *boltStore) Put(beacon *Beacon) error <span class="cov7" title="61">{
        err := b.db.Update(func(tx *bolt.Tx) error </span><span class="cov7" title="61">{
                bucket := tx.Bucket(beaconBucket)
                key := roundToBytes(beacon.Round)
                buff, err := beacon.Marshal()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="61">return bucket.Put(key, buff)</span>
        })
        <span class="cov7" title="61">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="61">return nil</span>
}

// ErrNoBeaconSaved is the error returned when no beacon have been saved in the
// database yet.
var ErrNoBeaconSaved = errors.New("beacon not found in database")

// Last returns the last beacon signature saved into the db
func (b *boltStore) Last() (*Beacon, error) <span class="cov8" title="92">{
        var beacon *Beacon
        err := b.db.View(func(tx *bolt.Tx) error </span><span class="cov8" title="90">{
                bucket := tx.Bucket(beaconBucket)
                cursor := bucket.Cursor()
                _, v := cursor.Last()
                if v == nil </span><span class="cov0" title="0">{
                        return ErrNoBeaconSaved
                }</span>
                <span class="cov8" title="90">b := &amp;Beacon{}
                if err := b.Unmarshal(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="90">beacon = b
                return nil</span>
        })
        <span class="cov8" title="92">return beacon, err</span>
}

// Get returns the beacon saved at this round
func (b *boltStore) Get(round uint64) (*Beacon, error) <span class="cov0" title="0">{
        var beacon *Beacon
        err := b.db.View(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                bucket := tx.Bucket(beaconBucket)
                v := bucket.Get(roundToBytes(round))
                if v == nil </span><span class="cov0" title="0">{
                        return ErrNoBeaconSaved
                }</span>
                <span class="cov0" title="0">b := &amp;Beacon{}
                if err := b.Unmarshal(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">beacon = b
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return beacon, err</span>
}

func (b *boltStore) Del(round uint64) error <span class="cov0" title="0">{
        return b.db.Update(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                bucket := tx.Bucket(beaconBucket)
                return bucket.Delete(roundToBytes(round))
        }</span>)
}

func (b *boltStore) Cursor(fn func(Cursor)) <span class="cov3" title="4">{
        b.db.View(func(tx *bolt.Tx) error </span><span class="cov3" title="4">{
                bucket := tx.Bucket(beaconBucket)
                c := bucket.Cursor()
                fn(&amp;boltCursor{Cursor: c})
                return nil
        }</span>)
}

type boltCursor struct {
        *bolt.Cursor
}

func (c *boltCursor) First() *Beacon <span class="cov0" title="0">{
        k, v := c.Cursor.First()
        if k == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">b := new(Beacon)
        if err := b.Unmarshal(v); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return b</span>
}

func (c *boltCursor) Next() *Beacon <span class="cov3" title="5">{
        k, v := c.Cursor.Next()
        if k == nil </span><span class="cov3" title="4">{
                return nil
        }</span>
        <span class="cov1" title="1">b := new(Beacon)
        if err := b.Unmarshal(v); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return b</span>
}

func (c *boltCursor) Seek(round uint64) *Beacon <span class="cov3" title="4">{
        k, v := c.Cursor.Seek(roundToBytes(round))
        if k == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="4">b := new(Beacon)
        if err := b.Unmarshal(v); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="4">return b</span>
}

func (c *boltCursor) Last() *Beacon <span class="cov0" title="0">{
        k, v := c.Cursor.Last()
        if k == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">b := new(Beacon)
        if err := b.Unmarshal(v); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return b</span>
}

type CallbackStore struct {
        Store
        cbs []func(*Beacon)
        sync.Mutex
}

// NewCallbackStore returns a Store that calls the given callback in a goroutine
// each time a new Beacon is saved into the given store. It does not call the
// callback if there has been any errors while saving the beacon.
func NewCallbackStore(s Store) *CallbackStore <span class="cov4" title="12">{
        return &amp;CallbackStore{Store: s}
}</span>

func (c *CallbackStore) Put(b *Beacon) error <span class="cov6" title="44">{
        if err := c.Store.Put(b); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="44">if b.Round != 0 </span><span class="cov6" title="44">{
                go func() </span><span class="cov6" title="44">{
                        c.Lock()
                        defer c.Unlock()
                        for _, cb := range c.cbs </span><span class="cov6" title="42">{
                                cb(b)
                        }</span>
                }()
        }
        <span class="cov6" title="44">return nil</span>
}

func (c *CallbackStore) AddCallback(fn func(*Beacon)) <span class="cov4" title="12">{
        c.Lock()
        defer c.Unlock()
        c.cbs = append(c.cbs, fn)
}</span>

func roundToBytes(r uint64) []byte <span class="cov10" title="324">{
        var buff bytes.Buffer
        binary.Write(&amp;buff, binary.BigEndian, r)
        return buff.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package beacon

import (
        "context"
        "errors"
        "time"

        "github.com/drand/drand/log"
        "github.com/drand/drand/net"
        proto "github.com/drand/drand/protobuf/drand"
        "google.golang.org/grpc/peer"
)

// SyncChain is the server side call that reply with the beacon in order to the
// client requesting the syncing.
func (h *Handler) SyncChain(req *proto.SyncRequest, p proto.Protocol_SyncChainServer) error <span class="cov8" title="13">{
        fromRound := req.GetFromRound()
        peer, _ := peer.FromContext(p.Context())
        addr := peer.Addr.String()
        last, _ := h.chain.Last()
        h.l.Debug("received", "sync_request", "from", peer.Addr.String(), "from_round", fromRound, "head_at", last.Round)
        if last.Round &lt; fromRound </span><span class="cov7" title="9">{
                return errors.New("no beacon stored above requested round")
        }</span>
        <span class="cov5" title="4">defer h.l.Debug("sync_reply_leave", addr)
        if fromRound == 0 </span><span class="cov0" title="0">{
                last, err := h.chain.Last()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h.l.Debug("sync_chain_reply", addr, "from", fromRound, "reply-last", last.Round)
                return p.Send(beaconToProto(last))</span>
        }
        <span class="cov5" title="4">var err error
        h.chain.Cursor(func(c Cursor) </span><span class="cov5" title="4">{
                for beacon := c.Seek(fromRound); beacon != nil; beacon = c.Next() </span><span class="cov6" title="5">{
                        reply := beaconToProto(beacon)
                        nRound, _ := NextRound(h.conf.Clock.Now().Unix(), h.conf.Group.Period, h.conf.Group.GenesisTime)
                        l, _ := h.chain.Last()
                        h.l.Debug("sync_chain_reply", addr, "from", fromRound, "to", reply.Round, "head", nRound-1, "last_beacon", l.String())
                        if err = p.Send(reply); err != nil </span><span class="cov0" title="0">{
                                h.l.Debug("sync_chain_reply", "err", err)
                                return
                        }</span>
                        <span class="cov6" title="5">fromRound = reply.Round</span>
                }
        })
        <span class="cov5" title="4">return err</span>
}

// syncChain will sync from the given rounds, to the targeted round until either
// the context closes or it exhausted the list of nodes to contact to.
func syncChain(ctx context.Context, l log.Logger, safe *cryptoSafe, from *Beacon, toRound uint64, client net.ProtocolClient) (chan *Beacon, error) <span class="cov5" title="4">{
        outCh := make(chan *Beacon, toRound-from.Round)
        fromRound := from.Round
        defer l.Debug("sync_from", fromRound, "leaving")

        info, err := safe.GetInfo(fromRound)
        if err != nil </span><span class="cov0" title="0">{
                l.Error("sync_no_round_info", fromRound)
                return nil, errors.New("no round info")
        }</span>
        <span class="cov5" title="4">var lastBeacon = from
        ids := shuffleNodes(info.group.Nodes)
        go func() </span><span class="cov5" title="4">{
                defer close(outCh)
                for _, id := range ids </span><span class="cov9" title="16">{
                        if id.Equal(info.id) </span><span class="cov4" title="3">{
                                continue</span>
                        }
                        <span class="cov8" title="13">request := &amp;proto.SyncRequest{
                                FromRound: lastBeacon.Round + 1,
                        }
                        l.Debug("sync_from", "try_sync", "to", id.Addr, "from_round", fromRound+1)
                        cctx, ccancel := context.WithCancel(context.Background())
                        respCh, err := client.SyncChain(cctx, id, request)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Error("sync_from", fromRound+1, "error", err, "from", id.Address())
                                ccancel()
                                continue</span>
                        }
                        <span class="cov8" title="13">func() </span><span class="cov8" title="13">{
                                addr := id.Address()
                                defer ccancel()
                                for </span><span class="cov10" title="18">{
                                        select </span>{
                                        case proto := &lt;-respCh:<span class="cov10" title="18">
                                                if proto == nil </span><span class="cov8" title="13">{
                                                        // because of the "select" behavior, sync returns an
                                                        // default proto beacon - that means channel is down
                                                        // so we log that as so
                                                        l.Debug("sync_from", addr, "from_round", fromRound, "sync_stopped")
                                                        return
                                                }</span>

                                                <span class="cov6" title="5">l.Debug("sync_from", addr, "from_round", fromRound, "got_round", proto.GetRound())
                                                newBeacon := protoToBeacon(proto)
                                                if !isAppendable(lastBeacon, newBeacon) </span><span class="cov0" title="0">{
                                                        l.Error("sync_from", addr, "from_round", fromRound, "want_round", lastBeacon.Round+1, "got_round", newBeacon.Round)
                                                        return
                                                }</span>
                                                <span class="cov6" title="5">info, err := safe.GetInfo(newBeacon.Round)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        l.Error("sync_from", addr, "invalid_round_info", newBeacon.Round)
                                                        return
                                                }</span>
                                                <span class="cov6" title="5">err = VerifyBeacon(info.pub.Commit(), newBeacon)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        l.Error("sync_from", addr, "invalid_beacon_sig", err, "round", newBeacon.Round)
                                                        return
                                                }</span>
                                                <span class="cov6" title="5">lastBeacon = newBeacon
                                                outCh &lt;- newBeacon</span>
                                        case &lt;-time.After(MaxSyncWaitTime):<span class="cov0" title="0">
                                                return</span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        }()
                        <span class="cov8" title="13">if lastBeacon.Round == toRound </span><span class="cov1" title="1">{
                                return
                        }</span>
                }
        }()
        <span class="cov5" title="4">return outCh, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package beacon

import (
        "time"

        clock "github.com/jonboulle/clockwork"
)

type ticker struct {
        clock   clock.Clock
        period  time.Duration
        genesis int64
        newCh   chan channelInfo
        stop    chan bool
}

func newTicker(c clock.Clock, period time.Duration, genesis int64) *ticker <span class="cov6" title="11">{
        t := &amp;ticker{
                clock:   c,
                period:  period,
                genesis: genesis,
                newCh:   make(chan channelInfo, 5),
                stop:    make(chan bool, 1),
        }
        go t.Start()
        return t
}</span>

func (t *ticker) Channel() chan roundInfo <span class="cov0" title="0">{
        newCh := make(chan roundInfo, 1)
        t.newCh &lt;- channelInfo{
                ch:      newCh,
                startAt: t.clock.Now().Unix(),
        }
        return newCh
}</span>

func (t *ticker) ChannelAt(start int64) chan roundInfo <span class="cov6" title="11">{
        newCh := make(chan roundInfo, 1)
        t.newCh &lt;- channelInfo{
                ch:      newCh,
                startAt: start,
        }
        return newCh
}</span>
func (t *ticker) Stop() <span class="cov6" title="11">{
        close(t.stop)
}</span>

func (t *ticker) CurrentRound() uint64 <span class="cov3" title="4">{
        return CurrentRound(t.clock.Now().Unix(), t.period, t.genesis)
}</span>

// Start will sleep until the next upcoming round and start sending out the
// ticks asap
func (t *ticker) Start() <span class="cov6" title="11">{
        chanTime := make(chan time.Time, 1)
        // whole reason of this function is to accept new incoming channels while
        // still sleeping until the next time
        go func() </span><span class="cov6" title="11">{
                now := t.clock.Now().Unix()
                _, ttime := NextRound(now, t.period, t.genesis)
                if ttime &gt; now </span><span class="cov6" title="11">{
                        t.clock.Sleep(time.Duration(ttime-now) * time.Second)
                }</span>
                // first tick happens at specified time
                <span class="cov6" title="11">chanTime &lt;- t.clock.Now()
                ticker := t.clock.NewTicker(t.period)
                defer ticker.Stop()
                tickChan := ticker.Chan()
                for </span><span class="cov9" title="43">{
                        select </span>{
                        case nt := &lt;-tickChan:<span class="cov8" title="32">
                                chanTime &lt;- nt</span>
                        case &lt;-t.stop:<span class="cov6" title="11">
                                return</span>
                        }
                }
        }()
        <span class="cov6" title="11">var channels []channelInfo
        var sendTicks = false
        var ttime int64
        var tround uint64
        for </span><span class="cov10" title="65">{
                if sendTicks </span><span class="cov9" title="43">{
                        sendTicks = false
                        info := roundInfo{
                                round: tround,
                                time:  ttime,
                        }
                        for _, chinfo := range channels </span><span class="cov9" title="41">{
                                if chinfo.startAt &gt; ttime </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov9" title="41">select </span>{
                                case chinfo.ch &lt;- info:<span class="cov9" title="41"></span>
                                default:<span class="cov0" title="0"></span>
                                        // pass on, do not send if channel is full
                                }
                        }
                }
                <span class="cov10" title="65">select </span>{
                case nt := &lt;-chanTime:<span class="cov9" title="43">
                        tround = CurrentRound(nt.Unix(), t.period, t.genesis)
                        ttime = nt.Unix()
                        sendTicks = true</span>
                case newChan := &lt;-t.newCh:<span class="cov6" title="11">
                        channels = append(channels, newChan)</span>
                case &lt;-t.stop:<span class="cov6" title="11">
                        for _, ch := range channels </span><span class="cov6" title="11">{
                                close(ch.ch)
                        }</span>
                        <span class="cov6" title="11">return</span>
                }
        }
}

type roundInfo struct {
        round uint64
        time  int64
}

type channelInfo struct {
        ch      chan roundInfo
        startAt int64
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
