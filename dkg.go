package main

import (
	"errors"
	"fmt"
	"strings"
	"sync"

	"github.com/nikkolasg/slog"

	"github.com/dedis/kyber/share/pedersen/dkg"
	"github.com/dedis/kyber/util/random"
)

// DKG is the structure responsible for running the DKG protocol.
type DKG struct {
	priv          *Private
	group         *Group
	store         Store
	addr          string
	n             int
	t             int
	idx           int
	router        *Router
	dkg           *dkg.DistKeyGenerator
	tmpResponses  map[uint32][]*dkg.Response
	sentDeals     bool
	dealProcessed int
	respProcessed int
	shareCh       chan Share
	done          bool
	sync.Mutex
}

func NewDKG(priv *Private, group *Group, r *Router, s Store) (*DKG, error) {
	d := &DKG{
		priv:   priv,
		group:  group,
		router: r,
		// default threshold
		t:            group.Threshold,
		addr:         priv.Public.Address,
		shareCh:      make(chan Share, group.Len()),
		store:        s,
		tmpResponses: make(map[uint32][]*dkg.Response),
	}
	d.idx, _ = group.Index(priv.Public)
	var err error
	// public key is in G2
	d.dkg, err = dkg.NewDistKeyGenerator(g2.(dkg.Suite), d.priv.Key, group.Points(), random.Stream, d.t)
	return d, err
}

// Start initiates the DKG protocol, it actively connects to every other nodes
// as an initiator. It returns the share generated if the protocol proceeded
// correctly.
func (d *DKG) Start() (*Share, error) {
	slog.Debugf("%s: Starting dkg as leader", d.addr)
	d.sentDeals = true
	if err := d.sendDeals(true); err != nil {
		return nil, err
	}
	slog.Debugf("%s: Waiting DKG shares as leader", d.addr)
	share := <-d.shareCh
	return &share, nil
}

// Run listens for any incoming DKG packet from an initiator. Once such a packet
// is received, it will start the DKG protocol by sending its shares. It returns
// the share generated by the protocol if it succeeded.
func (d *DKG) Run() (*Share, error) {
	share := <-d.shareCh
	slog.Debugf("%s: DKG.Run() Finished !", d.addr)
	return &share, nil
}

func (d *DKG) process(pub *Public, dkg *DKGPacket) {
	switch {
	case dkg.Deal != nil:
		d.processDeal(pub, dkg.Deal)
	case dkg.Response != nil:
		d.processResponse(pub, dkg.Response)
	case dkg.Justification != nil:
		panic("not yet implemented")
	}
}

func (d *DKG) processDeal(pub *Public, deal *dkg.Deal) {
	d.Lock()
	d.dealProcessed++
	slog.Debugf("%s: processDeal(%d) from %s", d.addr, d.dealProcessed, pub.Address)
	resp, err := d.dkg.ProcessDeal(deal)
	defer d.processTmpResponses(deal)
	defer d.Unlock()
	if err != nil {
		slog.Infof("%s error processing deal: %s", d.addr, err)
		return
	}

	if !d.sentDeals {
		d.sendDeals(false)
		d.sentDeals = true
		slog.Debugf("%s: sent DEALS !", d.addr)
	}
	packet := &DrandPacket{
		Dkg: &DKGPacket{
			Response: resp,
		},
	}
	d.broadcast(packet)
	slog.Debugf("%s: broadcasted Response !")
}

func (d *DKG) processTmpResponses(deal *dkg.Deal) {
	d.Lock()
	defer d.checkCertified()
	defer d.Unlock()
	resps, ok := d.tmpResponses[deal.Index]
	if !ok {
		return
	}
	slog.Debug(d.router.addr, "processing ", len(resps), " TEMP responses for dealer", deal.Index)
	delete(d.tmpResponses, deal.Index)
	for _, r := range resps {
		_, err := d.dkg.ProcessResponse(r)
		if err != nil {
			slog.Debugf(d.router.addr, ": err process temp response: ", err)
		}
	}
}
func (d *DKG) processResponse(pub *Public, resp *dkg.Response) {
	d.Lock()
	defer d.checkCertified()
	defer d.Unlock()
	d.respProcessed++
	j, err := d.dkg.ProcessResponse(resp)
	slog.Debugf("%s: processResponse(%d) from %s", d.addr, d.respProcessed, pub.Address)
	if err != nil {
		if strings.Contains(err.Error(), "no deal for it") {
			d.tmpResponses[resp.Index] = append(d.tmpResponses[resp.Index], resp)
			slog.Debug(d.router.addr, "storing future response for unknown deal ", resp.Index)
			return
		}
		panic(err)
		slog.Infof("%s error process response: %s", d.addr, err)
		return
	}
	if j != nil {
		slog.Debugf("%s: broadcasting Justification ", d.addr)
		packet := &DrandPacket{
			Dkg: &DKGPacket{
				Justification: j,
			},
		}
		go d.broadcast(packet)
	}
	slog.Debugf("%s: processResponse(%d) from %s --> Certified() ? %v --> done ? %v", d.addr, d.respProcessed, pub.Address, d.dkg.Certified(), d.done)
}

func (d *DKG) checkCertified() {
	d.Lock()
	defer d.Unlock()
	if !d.dkg.Certified() || d.done {
		return
	}
	//slog.Debugf("%s: processResponse(%d) from %s #3", d.addr, d.respProcessed, pub.Address)
	d.done = true
	slog.Infof("%s: dkg certified ", d.addr)
	dks, err := d.dkg.DistKeyShare()
	if err != nil {
		return
	}
	share := Share(*dks)
	d.shareCh <- share
}

// sendDeals tries to send the deals to each of the nodes. force indicates if
// the local nodeis the initiator or not, and therefore must actively initiates
// the connection or not.
// It returns an error if a number of node superior to the threshold have not
// received the deal. It is basically a no-go.
func (d *DKG) sendDeals(force bool) error {
	deals, err := d.dkg.Deals()
	if err != nil {
		return err
	}
	var send func(*Public, *DrandPacket) error
	if force {
		send = d.router.SendForce
	} else {
		send = d.router.Send
	}
	var good int = 1
	//z, _ := d.group.Index(d.priv.Public)
	//fmt.Printf("Index %d sendDeal() vs %d -- force ? %v\n ", d.idx, z, force)
	for i, deal := range deals {
		if i == d.idx {
			panic("stg's shaky")
		}
		pub := d.group.Public(i)
		packet := &DrandPacket{
			Dkg: &DKGPacket{
				Deal: deal,
			},
		}
		//fmt.Printf("%s sending deal to %s\n", d.addr, pub.Address)
		if err := send(pub, packet); err != nil {
			slog.Debugf("%s failed to send deal to %s: %s", d.priv.Public.Address, pub.Address, err)
		} else {
			good++
		}
	}
	if good < d.t {
		return fmt.Errorf("dkg: could only send deals to %d / %d (threshold %d)", good, d.n, d.t)
	}
	slog.Infof("%s: sentDeals FINISHED to %d nodes !", d.addr, good-1)
	return nil
}

func (d *DKG) expectDeal(buff []byte) (*dkg.Deal, error) {
	drand, err := unmarshal(g2, buff)
	if err != nil {
		return nil, err
	}

	if drand.Dkg == nil {
		return nil, errors.New("dkg: received non DKG packet...")
	}

	if drand.Dkg.Deal == nil {
		return nil, errors.New("dkg: expected a Deal but got none...")
	}
	return drand.Dkg.Deal, nil
}

func (d *DKG) broadcast(packet *DrandPacket) {
	slog.Debugf("%s: broadcast INIT", d.addr)
	for _, ip := range d.group.Nodes {
		if ip.Index == d.idx {
			continue
		}
		if err := d.router.Send(ip.Public, packet); err != nil {
			slog.Debugf("%s error sending packet to %s: %s", d.addr, ip.Address, err)
		}
	}
	slog.Debugf("%s: broadcast DONE", d.addr)
}
